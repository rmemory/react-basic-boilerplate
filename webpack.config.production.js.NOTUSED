const path = require('path');
const webpack = require('webpack');
const HtmlWebpackPlugin = require('html-webpack-plugin');
const ExtractTextPlugin = require('extract-text-webpack-plugin');

module.exports = {
	// Webpack configuration goes here

	/*
	 mode tells Webpack this configuration will be for either development or
	 production. “Development Mode [is] optimized for speed and developer
	 experience while Production defaults will give you a set of defaults
	 useful for deploying your application.
	 See:
	 https://medium.com/webpack/webpack-4-mode-and-optimization-5423a6bc597a
	 */
	mode: 'development',

	/* entry: Specifies the entry point of your application; this
	 is where the React app lives and where the bundling process
	 will begin. babel-polyfill is here because that's where the
	 docs for it tell me to add it (to make it globally availble)
	 */
	entry: {
		// Split out the vendor module, as its a big boy
		vendor: ['semantic-ui-react'],
		app: ['babel-polyfill', './src/index.js'],
	},

	/* output: Tells Webpack how to write the compiled files to disk.
	 Note that the webpack-development-server keeps everything in memory */

	output: {
		/* filename: This will be the filename of the bundled application.
		 The [hash] portion of the filename will be replaced by a hash generated by
		 Webpack every time your application changes and is recompiled (helps with
		 caching).

		 Production builds are put into static dir
		 */
		filename: 'static/[name].[hash].js',

		/* Absolute path to the desired output directory. In our
		   case a directory named 'dist'
		   '__dirname' is a Node variable that gives us the absolute
		   path to our current directory. Then with 'path.resolve' we
		   join directories
		   Webpack 4 assumes your output path will be './dist' so you
		   could just leave this
		   entry out. */
		path: path.resolve(__dirname, 'dist'),

		/* publicPath is an important option when using on-demand-loading or
		   loading external resources like images, files, etc. If an incorrect
		   value is specified you'll receive 404 errors while loading these
		   resources. And Hot reloading won’t work as expected for nested routes
		   without it */
		publicPath: '/',
	},

	/*
	  Use production source maps
	  See the docs:
	 https://webpack.js.org/configuration/devtool/
	 */
	devtool: 'source-map',

	/* Module: What types of modules your application will include, in our case we
	 will support ESNext (Babel) and CSS Modules.

	 rules: How we handle each different type of module. Here is how rules usually work:
	 {
		test: /\.YOUR_FILE_EXTENSION$/,
		exclude: /SOMETHING THAT IS THAT EXTENSION BUT SHOULD NOT BE PROCESSED/,
		use: {
		  loader: "loader for your file extension  or a group of loaders"
		}
}
	 */
	module: {
		rules: [

			// First Rule, test for .js and .jsx files (I prefer using .jsx)
			{
				test: /\.js|.jsx?$/,

				// Don't allow the babel-loader to traverse the node_modules directory
				exclude: /node_modules/,

				/* The babel-loader will check in the .babelrc for the presets */
				use: ['babel-loader'],
			},

			// Second Rule

			/* test for CSS files with a .css extension. Here we use two loaders,
			   style-loader and css-loader, to handle our CSS files. Then we instruct
			   css-loader to use CSS Modules, camel case and create source maps.
			 */
			{
				test: /\.css$/,

				// configure 'Extract Text Plugin'
				use: ExtractTextPlugin.extract({
					// loader that should be used when the
					// CSS is not extracted
					fallback: 'style-loader',
					use: [
						{
							loader: 'css-loader',
							options: {
								modules: true,
								// Allows to configure how many loaders
								// before css-loader should be applied
								// to @import(ed) resources
								importLoaders: 1,
								camelCase: true,
								// Create source maps for CSS files
								sourceMap: true,
							},
						},
						{
							// PostCSS will run before css-loader and will
							// minify and autoprefix our CSS rules. We are also
							// telling it to only use the last 2
							// versions of the browsers when autoprefixing
							loader: 'postcss-loader',
							options: {
								config: {
									ctx: {
										autoprefixer: {
											browsers: 'last 2 versions',
										},
									},
								},
							},
						},
					],
				}),
			},
		],
	},
	// This creates the index.html, using the ./src/index.html as a
	// starting template
	plugins: [
		/* Prints more readable module names in the browser terminal on HMR updates */
		new webpack.NamedModulesPlugin(),
		new webpack.HotModuleReplacementPlugin(),
		new HtmlWebpackPlugin({
			// With no arg, the plugin would attempt to create its own HTML file,
			// but we specify a template instead
			template: 'public/index.html',
			favicon: 'public/favicon.ico',
		}),

		// Create the stylesheet under 'styles' directory
		new ExtractTextPlugin({
			filename: 'styles/styles.[hash].css',
			allChunks: true,
		}),
	],

	/*
	This makes sure the vendor bundle size is as small as possible. See
	https://github.com/webpack/webpack/issues/6357
	 */
	optimization: {
		splitChunks: {
			cacheGroups: {
				vendor: {
					chunks: 'initial',
					test: 'vendor',
					name: 'vendor',
					enforce: true,
				},
			},
		},
	},
};
